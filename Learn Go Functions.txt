# LEARN GO: FUNCTIONS
---------------------

* What is a Function?
---------------------
In programming, a function is a block of code designed to be reused. As programmers, we want to find solutions to problems, but we also don’t want to do additional work when it’s not 
necessary. Let’s start with an example, say we needed to double a number:

	x := 5 
	doubleX := 5 * 2

Great, but what if we need to double another number?

	y := 3 
	doubleY := 3 * 2

And another??

	z := 25
	doubleZ := 25 * 2

These short bits of code could build up to a lot of time and effort (just to double a number!) That’s where functions can really help out. We can use a function to define the logic for us 
to perform this task, and call it (execute its code) when we need it:

	func doubleNum(num int) int {
  		return num * 2
	}

Don’t worry too much about the syntax for now, but it should look pretty familiar since we’ve worked with the main() function many times before (Reminder: one of the major differences is 
that the main() doesn’t have to be called, because the compiler already knows to run it). Our doubleNum() function will allow us to plug in numbers and it returns an integer that’s twice 
the number given! Also, if our outputs start looking weird, e.g. our numbers aren’t doubling, but tripling instead, we know that the cause is likely our function. We can jump straight to 
fixing our function’s code rather than looking through each statement like we had for doubleX, doubleY, and doubleZ. Our code becomes much more streamlined:

	fmt.Println(doubleNum(x)) // Prints: 10
	fmt.Println(doubleNum(y)) // Prints: 6
	fmt.Println(doubleNum(z)) // Prints: 50

We’ll go over more examples of how to create and use functions, when they can be accessed, and how to defer within a function later in this lesson. In a nutshell, we’ll see how functions 
function.

* Instructions
--------------
Take a look at the provided GIF. It shows a function, named addOneSide(), adding an additional side to different shape inputs. Notice how there is only one function, represented by the 
box, that is used to transform individual shapes (inputs) into new shapes (outputs).

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Using Functions
-----------------
As we saw before, we can bundle code in a function and call that function when we need the code inside it to run. We’ll be going over function syntax starting with a simple function 
definition:

	func summonNicole() {
  		fmt.Println("Hey Nicole, get over here!")
	}

Above, we defined a function called summonNicole() and, within the body of the function (the part between the curly braces) we print out a message. It’s important to note that the code 
inside the function body does not run until we call the function. We call a function by using its name followed by parentheses somewhere outside the definition of the function. Our whole main.go file could look like this:

package main

import "fmt"

func summonNicole() {
  fmt.Println("Hey Nicole, get over here!")
}

func main() {
  // We call our function for the first time
  summonNicole() 

  // We call our function for the second time
  summonNicole() 
}

In our example, we defined the function summonNicole() and called it twice inside our main() function. Notice that our function definition exists outside of main(), but calling summonNicole() occurs inside our main() function. This produces the following output in the terminal:

	Hey Nicole, get over here!
	Hey Nicole, get over here!

Now, let’s create our own functions.

* Instructions
--------------
Checkpoint 1 Passed
1.
Define a function called eatTacos() that uses fmt.Println() to print out the message "Yum!".


Hint
Define a function using the func keyword, the function’s name, parentheses, and then add the code for it to perform between curly braces:

func myFunction() {
  fmt.Println("Sure is neat to write my own functions!")
}

Checkpoint 2 Passed
2.
Call eatTacos() from within our main() function. main() is a function too, so in a sense you’ve already been writing your own functions!


Hint
Call eatTacos() within the curly braces inside main():

func main() {
  myFunction()
}

main.go
-------
package main

import "fmt"

// Define eatTacos() here:
func eatTacos() {
  fmt.Println("Yum!")
}

func main() {
  // Call your function here:
  eatTacos()
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

* Scope
-------
A function definition creates something called a scope. We’ve referenced scope before in our conditionals exercise about scoped short declarations but it’s important to recognize how 
scope plays a huge role in functions and programming overall!

Scope is a concept that refers to where the values and functions are defined and where they can be accessed. For instance, when a variable is defined within a function, that variable is 
only accessible within that function. When we try to access that same variable from a different function, we get an error because we can’t do it. Each function has its own specific scope, 
take a look at the code:

package main

import "fmt"

func performAddition() {
  x := 5
  y := 7
  fmt.Println("The sum of", x, "and", y, "is", x + y)
}

func main() {
  performAddition()
  fmt.Println("What if", x, "was different?")
}

The above code exits with the following error:

./main.go:12:26: undefined: x

The error is raised because the x in main()‘s print statement fmt.Println("What if", x, "was different?") is in a different scope than the defined x inside performAddition(). It’s not 
possible to directly refer to performAddition()‘s x variable in the scope of main().

There are three different scopes present in this example:

	. The global scope, which contains the function definitions for main() and performAddition().

	. performAddition() has a local scope, which defines x and y.

	. main() has a local scope also. It can access performAddition() because that’s defined on the same scope level as main() but can’t access the internals of performAddition‘s scope 
	(i.e., x or y).

This differentiation of scope keeps the namespace, the available variables and keywords, cleaner as a result. You can only refer to variables or functions defined within a specific 
namespace.

* Instructions
--------------
Checkpoint 1 Passed
1.
In main.go we have a function that creates the instructions for the start of a game. We’re trying to access the string so that we can print it, but it’s in a different scope from the one 
our print statement is.

Move the fmt.Println(instructions) statement from the main() function body into startGame()‘s body.


Hint
Remove the fmt.Println() from main() and then put it in startGame():

func startGame() {
  instructions := "Press enter to start..."  
  fmt.Println(instructions)
}

main.go
-------
package main

import "fmt"

func startGame() {
  instructions := "Press enter to start..." 
  fmt.Println(instructions)
  
  
}

func main() {
  startGame()  
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------








































































