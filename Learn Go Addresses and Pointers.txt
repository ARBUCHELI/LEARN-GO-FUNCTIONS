# LEARN GO: ADDRESSES AND POINTERS
----------------------------------

* The Point of Pointers and Addresses
-------------------------------------
Go is a pass-by-value language. In other words, we’re passing functions the value of an argument. In a technical sense, when we’re calling a function with an argument, the Go compiler is 
strictly using the value of the argument rather than the argument itself. Because of this feature (pass-by-value), the changes that take place in our function, stay within that function.

Picture a teacher with a classroom of students and the teacher needs the students to complete a worksheet. The teacher will have the original copy of the worksheet and make copies for 
his/her students to write on, but the students are not directly writing on the teacher’s copy.

But, we do have the ability to change values from different scopes. To do so, we need to make use of:

	. addresses
	. pointers
	. dereferencing

Now that we know what topics we need to reference, let’s quickly address this situation and get to the point!

* Instructions
--------------
Read through the code provided and think about what is supposed to be printed out. Does the value of x change? In the next couple of exercises, we’ll explore the why.

main.go
-------
package main

import "fmt"

func addHundred(num int) {
  num += 100
}

func main() {
  x := 1
  
  addHundred(x)
  
  fmt.Println(x) 
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Addresses
-----------
Picture being in class and taking part in a lesson. When we hear an important detail, we write it down in our notebook for reference later. This same idea of storing important information 
somewhere is the reason why we declare variables in Go. But instead of writing information down in a notebook, a computer sets aside some space in its memory to store the value. The space 
that the computer allocates is called an address. Each address is marked as a unique numerical value.

Every time we use a variable, what we’re doing is retrieving the value stored at the variable’s address. Here’s a simple visualization:

Go diagram showing memory addresses with corresponding hexadecimal values for the addresses

To find a variable’s address we use the & operator followed by the variable name, like so:

x := "My very first address"
fmt.Println(&x) // Prints 0x414020

When we see the 0x prefix, this means that the number is in formatted in hexadecimal, which is a way of representing 16 digit numbers. Thus, the 0x414020 is actually the address of x in hexadecimal format.

Let’s print out the address of a variable for ourselves.

* Instructions
--------------
Checkpoint 1 Passed
1.
Given the treasure variable, print out the address of the variable.


Hint
To find the address, use the & operator the name of the variable, like so:

x := "Hello!"
fmt.Println(&x)

main.go
-------
package main

import "fmt"

func main() {
	treasure := "The friends we make along the way."
	
	// Add your code below:
fmt.Println(&treasure)
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Pointers
----------
In the previous exercise we went over addresses, now let’s learn how to store them. In Go, pointers do that job for us. Pointers are variables that specifically store addresses.

We even set the data type of the addresses’ value for the pointer. For instance:

	var pointerForInt *int

In the example above pointerForInt will store the address of a variable that has an int data type. To break it down further, the * operator signifies that this variable will store an 
address and the int portion means that the address contains an integer value.

With pointerForInt initialized, we can assign it value like so:

	var pointerForInt *int

	minutes := 525600

	pointerForInt = &minutes

	fmt.Println(pointerForInt) // Prints 0xc000018038

Notice in our example that minutes has a value of 525600, an integer type. Since we’ve initialized pointerForInt as a pointer that will hold the address of an integer value, we can then 
assign the address of minutes (&minutes) to pointerForInt. Printing out pointerForInt, we get another hexadecimal number: 0xc000018038.

We can also declare a pointer implicitly like other variables:

	minutes := 55

	pointerForInt := &minutes

Let’s see how we would create a pointer for a string instead!

* Instructions
--------------
Checkpoint 1 Passed
1.
Given the string star, create a pointer called starAddress that holds the address of star.


Hint
You may initialize starAddress first and then assign it a value or directly declare it using :=.

Checkpoint 2 Passed
2.
Print out the string "The address of star is" followed by the value of starAddress.

main.go
-------
package main

import "fmt"

func main() {
	star := "Polaris"
	
	// Add your code below:
  starAddress := &star
  fmt.Println("The address of star is ", starAddress)
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Dereferencing
---------------
We know that addresses are where values are stored and pointers allow us to keep track of addresses. But what if we want the address to store a different value? Well, we can actually use 
our pointer to access the address and change its value! This action is called dereferencing or indirecting.

We’ll need to use the * operator again on a pointer and then assign a new value like so:

lyrics := "Moments so dear" 
pointerForStr := &lyrics

*pointerForStr = "Journeys to plan" 

fmt.Println(lyrics) // Prints: Journeys to plan

In our example, we have our variables: lyrics that has the value of "Moments so dear" and pointerForStr which is a pointer for lyrics. Then we use the * operator on pointerForStr to 
dereference it and assign a new value of "Journeys to plan". When we check the value of lyrics it’s now "Journeys to plan"!

* Instructions
--------------
Checkpoint 1 Passed
1.
Let’s incorporate what we learned and update the value of star. Dereference starAddress and assign it a value of "Sirius".


Hint
starAddress is a pointer that holds the address of star. We’re changing the value of star by dereferencing starAddress. To reassign a new value using dereferencing, use the following 
syntax:

greeting := "Hello"
greetPtr := &greeting

*greetPtr = "Yo" 
// To check that greeting has its value changed:
fmt.Println(greeting) // Prints Yo

main.go
-------
package main

import "fmt"

func main() {
	star := "Polaris"
	
	starAddress := &star
	
	// Add your code below:
  *starAddress = "Sirius"
	
	
  
  fmt.Println("The actual value of star is", star)
}


------------------------------------------------------------------------------------------------------------------------------------------------------------------































































































